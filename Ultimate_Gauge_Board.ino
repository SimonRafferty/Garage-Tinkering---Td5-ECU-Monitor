
#include <Arduino.h>
// ============================================================================
// Board: Garage Tinkering Ultimate Display
// ESP32 S3 Dev Module
// ---------------------------------
// Before compile set:
// ---------------------------------
// USB CDC on Boot: ENABLE
// Flash Size: 8MB
// Partition Scheme: Huge App
// PS RAM: OPI PSRAM
// ============================================================================
// Designed to display ESPNow data generated by my Td5 ECU Interface
// https://github.com/SimonRafferty/Land-Rover-Td5-Arduino-Diagnostics
// ============================================================================
// DATA SOURCE SELECTION - Choose ONE
// ============================================================================
//#define USE_CANBUS        // Receive data via CAN bus (original mode)
#define USE_ESPNOW        // Receive data via ESP-NOW wireless (Td5 ECU Interface)



// ============================================================================
// GAUGE CONFIGURATION - Select data source and display parameters
// ============================================================================
enum GaugeDataSource {
  GAUGE_COOLANT_TEMP,     // Coolant temperature (°C)
  GAUGE_ENGINE_RPM,       // Engine RPM
  GAUGE_BOOST_PRESSURE,   // Turbo boost pressure (kPa)
  GAUGE_VEHICLE_SPEED,    // Vehicle speed (km/h)
  GAUGE_FUEL_TEMP,        // Fuel temperature (°C)
  GAUGE_INLET_AIR_TEMP,   // Inlet air temperature (°C)
  GAUGE_BATTERY_VOLTAGE,  // Battery voltage (V)
  GAUGE_THROTTLE_POS,     // Throttle position (%)
  GAUGE_MANIFOLD_PRESSURE,// Manifold absolute pressure (kPa)
  GAUGE_EGR_POSITION      // EGR valve position (%)
};

// Configure your gauge here:
struct GaugeConfig {
  GaugeDataSource dataSource;   // What to display
  const char* displayName;      // Name shown on gauge (e.g., "Coolant Temp")
  const char* units;            // Units shown on gauge (e.g., "°C")
  int scaleMin;                 // Minimum scale value (scaled by multiplier)
  int scaleMax;                 // Maximum scale value (scaled by multiplier)
  int tickCount;                // Number of tick marks around gauge circumference
  int overrangePercent;         // Percentage above which to show red arc (100 = no red arc)
  int underrangePercent;        // Percentage below which to show red arc (0 = no red arc)
  int averageWindow;            // Moving average window size (1 = no averaging)
  float displayMultiplier;      // Multiply final value for display (e.g., 10 for one decimal)
} gaugeConfig = {
  // Example: Coolant temperature gauge
  .dataSource = GAUGE_ENGINE_RPM,
  .displayName = "Tacho",
  .units = "RPM",
  .scaleMin = 00,             // -20.0°C (scaled by 10)
  .scaleMax = 5700,             // 140.0°C (scaled by 10)
  .tickCount = 6,               // Number of tick marks
  .overrangePercent = 85,       // Red arc above 85% (119°C)
  .underrangePercent = 20,       // No underrange red arc
  .averageWindow = 10,          // 10-sample moving average
  .displayMultiplier = 1.0     // Display with 0 decimal place

  // Example configurations for other data sources:

  // Engine RPM:
  // .dataSource = GAUGE_ENGINE_RPM,
  // .displayName = "Engine RPM",
  // .units = "RPM",
  // .scaleMin = 0,
  // .scaleMax = 5000,
  // .tickCount = 11,
  // .overrangePercent = 80,    // Red line at 4000 RPM
  // .underrangePercent = 0,
  // .averageWindow = 5,
  // .displayMultiplier = 1.0

  // Boost Pressure:
  // .dataSource = GAUGE_BOOST_PRESSURE,
  // .displayName = "Boost",
  // .units = "kPa",
  // .scaleMin = 0,
  // .scaleMax = 200,
  // .tickCount = 9,
  // .overrangePercent = 90,    // Red line at 180 kPa
  // .underrangePercent = 0,
  // .averageWindow = 8,
  // .displayMultiplier = 1.0

  // Battery Voltage:
  // .dataSource = GAUGE_BATTERY_VOLTAGE,
  // .displayName = "Battery",
  // .units = "V",
  // .scaleMin = 100,            // 10.0V (scaled by 10)
  // .scaleMax = 160,            // 16.0V (scaled by 10)
  // .tickCount = 7,
  // .overrangePercent = 95,    // Red line at 15.7V
  // .underrangePercent = 17,   // Red line below 11.0V
  // .averageWindow = 20,
  // .displayMultiplier = 10.0
};

#include "LVGL_Driver.h"
#include "I2C_Driver.h"

#ifdef USE_CANBUS
  #include "CANBus_Driver.h"
  #include <freertos/FreeRTOS.h>
  #include <freertos/task.h>
  #include "freertos/queue.h"

  QueueHandle_t canMsgQueue;
  #define CAN_QUEUE_LENGTH 32
  #define CAN_QUEUE_ITEM_SIZE sizeof(twai_message_t)
#endif

#ifdef USE_ESPNOW
  #include "ESPNow_Driver.h"
#endif

// IMAGES - include image asset definitions
#include "tabby_needle.h"
#include "tabby_tick.h"

// DATA STORE
typedef struct struct_gauge_data {
  int scale_value;
}struct_gauge_data;

struct_gauge_data GaugeData;

// CONTROL CONSTANTS (derived from gaugeConfig)
// Note: These must be compile-time constants for array sizing
#define AVERAGE_VALUES      (gaugeConfig.averageWindow)
#define SCALE_MIN           (gaugeConfig.scaleMin)
#define SCALE_MAX           (gaugeConfig.scaleMax)
#define SCALE_TICKS_COUNT   (gaugeConfig.tickCount)

const bool TESTING            = true; // set to true for needle sweep testing

// Dynamically allocate tick marks array in setup
lv_obj_t **scale_ticks = nullptr;

#define TAG "TWAI"

// CONTROL VARIABLE INIT
bool receiving_data           = false; // has the first data been received
volatile bool data_ready      = false; // new incoming data
bool init_anim_complete       = false; // needle sweep completed
bool status_led               = false; // flashing LED for CAN activity

// ROLLING AVERAGE FOR SMOOTHING
int scale_moving_average  = 0;

// GLOBAL COMPONENTS
lv_obj_t *main_scr;
lv_obj_t *scale;
lv_obj_t *needle_img;

void drivers_init(void) {
  i2c_init();

  Serial.println("Scanning for TCA9554...");
  bool found = false;
  for (int attempt = 0; attempt < 10; attempt++) {
  if (i2c_scan_address(0x20)) { // 0x20 is default for TCA9554
      found = true;
      break;
    }
    delay(50); // wait a bit before retrying
  }

  if (!found) {
    Serial.println("TCA9554 not detected! Skipping expander init.");
  } else {
  tca9554pwr_init(0x00);
  }
  lcd_init();

  // Initialize data source
  #ifdef USE_CANBUS
    canbus_init();
    Serial.println("Data source: CAN Bus");
  #endif

  #ifdef USE_ESPNOW
    espnow_init();
    Serial.println("Data source: ESP-NOW");
  #endif

  lvgl_init();
}

// Extract gauge value from the configured data source
int get_gauge_value_from_source() {
  #ifdef USE_ESPNOW
    // Extract value based on configured data source
    switch (gaugeConfig.dataSource) {
      case GAUGE_COOLANT_TEMP:
        return espnow_data.coolantTemp;

      case GAUGE_ENGINE_RPM:
        return espnow_data.engineRPM;

      case GAUGE_BOOST_PRESSURE:
        return espnow_data.boostPressure;

      case GAUGE_VEHICLE_SPEED:
        return espnow_data.vehicleSpeed;

      case GAUGE_FUEL_TEMP:
        return espnow_data.fuelTemp;

      case GAUGE_INLET_AIR_TEMP:
        return espnow_data.inletAirTemp;

      case GAUGE_BATTERY_VOLTAGE:
        return espnow_data.batteryVoltage / 100;  // Convert mV to V*10

      case GAUGE_THROTTLE_POS:
        return espnow_data.driverDemand / 10;  // Convert % * 100 to % * 10

      case GAUGE_MANIFOLD_PRESSURE:
        return espnow_data.manifoldPressure;

      case GAUGE_EGR_POSITION:
        return espnow_data.egrPosition / 10;  // Convert % * 100 to % * 10

      default:
        return 0;
    }
  #endif

  #ifdef USE_CANBUS
    // For CAN bus, value is already in GaugeData.scale_value
    return GaugeData.scale_value;
  #endif

  return 0;
}

// create moving average for smoothing and scale by display multiplier
int get_moving_average(int new_value) {
    // Use max possible window size for static allocation
    #define MAX_AVERAGE_WINDOW 30
    static int values[MAX_AVERAGE_WINDOW] = {0};
    static int index = 0;
    static int count = 0;
    static double sum = 0;

    // Get actual window size from config
    int window_size = gaugeConfig.averageWindow;
    if (window_size > MAX_AVERAGE_WINDOW) window_size = MAX_AVERAGE_WINDOW;

    // Subtract the value being replaced
    sum -= values[index];

    // Insert the new value
    values[index] = new_value;
    sum += new_value;

    // Update index and count
    index = (index + 1) % window_size;
    if (count < window_size) count++;

    float avg = sum / count;

    return (int)roundf(avg * gaugeConfig.displayMultiplier);
}


static int previous_scale_value = 0;

// update the UI with the latest value
static void set_needle_img_value(void * obj, int32_t v) {
  lv_scale_set_image_needle_value(scale, needle_img, v);
}

void update_scale(void) {
  // Get value from configured data source
  int raw_value = get_gauge_value_from_source();

  // use a moving average of the last x values for smoothing
  int averaged_value = get_moving_average(raw_value);

  lv_anim_t anim;
  lv_anim_init(&anim);
  lv_anim_set_var(&anim, scale); // 'scale' is your needle object
  lv_anim_set_values(&anim, previous_scale_value, averaged_value);
  lv_anim_set_time(&anim, 100); // 100ms duration
  lv_anim_set_exec_cb(&anim, (lv_anim_exec_xcb_t)set_needle_img_value);
  lv_anim_start(&anim);

  previous_scale_value = averaged_value;
}

// update parts with incoming values
void update_values(void) {
  update_scale();
}

// mark the loader as complete
void needle_sweep_complete(lv_anim_t *a) {
    init_anim_complete = true;
}

// scroll the needle from min to the current value
void needle_to_current(lv_anim_t *a) {
  lv_anim_t anim_scale_img;
  lv_anim_init(&anim_scale_img);
  lv_anim_set_var(&anim_scale_img, scale);
  lv_anim_set_exec_cb(&anim_scale_img, set_needle_img_value);
  lv_anim_set_duration(&anim_scale_img, 1000);
  lv_anim_path_ease_out(&anim_scale_img);
  lv_anim_set_values(&anim_scale_img, SCALE_MIN, receiving_data ? scale_moving_average : SCALE_MIN);
  lv_anim_set_ready_cb(&anim_scale_img, needle_sweep_complete);
  lv_anim_start(&anim_scale_img);
}

// 0 to max to 0 sweep on load
void needle_sweep() {
  if (TESTING) {
    // Continuous back and forth sweep for testing using gaugeConfig range
    lv_anim_t anim_scale_img;
    lv_anim_init(&anim_scale_img);
    lv_anim_set_var(&anim_scale_img, scale);
    lv_anim_set_exec_cb(&anim_scale_img, set_needle_img_value);
    lv_anim_set_duration(&anim_scale_img, 10000);
    lv_anim_set_repeat_count(&anim_scale_img, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_playback_duration(&anim_scale_img, 10000);
    lv_anim_set_values(&anim_scale_img, SCALE_MIN, SCALE_MAX);  // Use configured range
    lv_anim_start(&anim_scale_img);
  } else {
    // Normal startup sweep: min to max and back to current value
    lv_anim_t anim_scale_img;
    lv_anim_init(&anim_scale_img);
    lv_anim_set_var(&anim_scale_img, scale);
    lv_anim_set_exec_cb(&anim_scale_img, set_needle_img_value);
    lv_anim_set_duration(&anim_scale_img, 2000);
    lv_anim_set_repeat_count(&anim_scale_img, 1);
    lv_anim_set_playback_duration(&anim_scale_img, 1000);
    lv_anim_set_values(&anim_scale_img, SCALE_MIN, SCALE_MAX);  // Use configured range
    lv_anim_set_ready_cb(&anim_scale_img, needle_to_current);
    lv_anim_start(&anim_scale_img);
  }
}

void make_scale_ticks(void) {
  // Allocate scale_ticks array dynamically
  scale_ticks = (lv_obj_t **)malloc(SCALE_TICKS_COUNT * sizeof(lv_obj_t *));
  if (scale_ticks == nullptr) {
    Serial.println("ERROR: Failed to allocate scale_ticks array");
    return;
  }

  for (int i = 0; i < SCALE_TICKS_COUNT; i++) {
    scale_ticks[i] = lv_image_create(main_scr);
    lv_image_set_src(scale_ticks[i], &tabby_tick);
    lv_obj_align(scale_ticks[i], LV_ALIGN_CENTER, 0, 196);
    lv_image_set_pivot(scale_ticks[i], 14, -182);

    lv_obj_set_style_image_recolor_opa(scale_ticks[i], 255, 0);
    lv_obj_set_style_image_recolor(scale_ticks[i], lv_color_make(255,255,255), 0); // TO DO - replace with color from CAN

    int rotation_angle = (((i) * (240 / (SCALE_TICKS_COUNT - 1))) * 10); // angle calculation

    lv_image_set_rotation(scale_ticks[i], rotation_angle);
  }
}

// create the elements on the main scr
void main_scr_ui(void) {

  // scale used for needle
  scale = lv_scale_create(main_scr);
  lv_obj_set_size(scale, 480, 480);
  lv_scale_set_mode(scale, LV_SCALE_MODE_ROUND_INNER);
  lv_obj_set_style_bg_opa(scale, LV_OPA_0, 0);
  lv_scale_set_total_tick_count(scale, 0);
  lv_scale_set_label_show(scale, false);
  lv_obj_center(scale);
  lv_scale_set_range(scale, SCALE_MIN, SCALE_MAX);
  lv_scale_set_angle_range(scale, 240);
  lv_scale_set_rotation(scale, 90);

  // Calculate red arc angles based on percentage settings
  // Gauge starts at 90° and spans 240° (ending at 330°)
  int start_angle = 90;
  int total_arc_angle = 240;

  // Underrange red arc (low end) - only show if underrangePercent > 0
  if (gaugeConfig.underrangePercent > 0) {
    int underrange_arc_length = (total_arc_angle * gaugeConfig.underrangePercent) / 100;
    int underrange_end_angle = start_angle + underrange_arc_length;

    lv_obj_t *lower_arc = lv_arc_create(main_scr);
    lv_obj_set_size(lower_arc, 420, 420);
    lv_arc_set_bg_angles(lower_arc, start_angle, underrange_end_angle);
    lv_arc_set_value(lower_arc, 0);
    lv_obj_center(lower_arc);
    lv_obj_set_style_opa(lower_arc, 0, LV_PART_KNOB);
    lv_obj_set_style_arc_color(lower_arc, lv_color_make(87,10,1), LV_PART_MAIN);
    lv_obj_set_style_arc_width(lower_arc, 28, LV_PART_MAIN);
    lv_obj_set_style_arc_rounded(lower_arc, false, LV_PART_MAIN);
  }

  // Overrange red arc (high end) - only show if overrangePercent < 100
  if (gaugeConfig.overrangePercent < 100) {
    int overrange_arc_length = (total_arc_angle * (100 - gaugeConfig.overrangePercent)) / 100;
    int overrange_start_angle = (start_angle + total_arc_angle) - overrange_arc_length;
    int overrange_end_angle = start_angle + total_arc_angle;

    lv_obj_t *upper_arc = lv_arc_create(main_scr);
    lv_obj_set_size(upper_arc, 420, 420);
    lv_arc_set_bg_angles(upper_arc, overrange_start_angle, overrange_end_angle);
    lv_arc_set_value(upper_arc, 0);
    lv_obj_center(upper_arc);
    lv_obj_set_style_opa(upper_arc, 0, LV_PART_KNOB);
    lv_obj_set_style_arc_color(upper_arc, lv_color_make(87,10,1), LV_PART_MAIN);
    lv_obj_set_style_arc_width(upper_arc, 28, LV_PART_MAIN);
    lv_obj_set_style_arc_rounded(upper_arc, false, LV_PART_MAIN);
  }

  make_scale_ticks();

  // needle image
  int needle_center_shift = 40; // how far the center of the needle is shifted from the left edge

  needle_img = lv_image_create(scale);
  lv_image_set_src(needle_img, &tabby_needle);
  lv_obj_align(needle_img, LV_ALIGN_CENTER, 108 - needle_center_shift, 0);
  lv_image_set_pivot(needle_img, needle_center_shift, 36);

  lv_obj_set_style_image_recolor_opa(needle_img, 255, 0);
  lv_obj_set_style_image_recolor(needle_img, lv_color_make(255,255,255), 0); // TO DO - replace with color from CAN

  // Gauge name label (center, above units)
  // Using lv_font_montserrat_16 (enabled in lv_conf.h)
  lv_obj_t *gauge_name_label = lv_label_create(main_scr);
  lv_label_set_text(gauge_name_label, gaugeConfig.displayName);
  lv_obj_set_style_text_font(gauge_name_label, &lv_font_montserrat_16, 0);  // 16pt font for name
  lv_obj_set_style_text_color(gauge_name_label, lv_color_make(255, 255, 255), 0);
  lv_obj_align(gauge_name_label, LV_ALIGN_CENTER, 0, -18);

  // Units label (center, below name, larger font)
  // Using lv_font_montserrat_22 (enabled in lv_conf.h)
  lv_obj_t *units_label = lv_label_create(main_scr);
  lv_label_set_text(units_label, gaugeConfig.units);
  lv_obj_set_style_text_font(units_label, &lv_font_montserrat_22, 0);  // 22pt font for units
  lv_obj_set_style_text_color(units_label, lv_color_make(255, 255, 255), 0);
  lv_obj_align(units_label, LV_ALIGN_CENTER, 0, 8);
}

// build the screens
void screens_init(void) {
  main_scr = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(main_scr, lv_color_make(0,0,0), 0);
  lv_screen_load(main_scr);

  main_scr_ui();
}

#ifdef USE_CANBUS
// process incoming CAN coolante temp message
void process_scale_value(uint8_t *byte_data) {
  //byte 0
  //modifier -40
  int byte_pos = 0;

  int final_temp = byte_data[byte_pos] - 40; // reduce value by 40 (Nissan specific)


  GaugeData.scale_value = final_temp;
}

void receive_can_task(void *arg) {
  while (1) {
    twai_message_t message;
    esp_err_t err = twai_receive(&message, pdMS_TO_TICKS(5)); // lower timeout for faster response
    if (err == ESP_OK) {
      if (xQueueSend(canMsgQueue, &message, 0) != pdPASS) {
        ESP_LOGW(TAG, "CAN queue full, message dropped");
      }
      vTaskDelay(pdMS_TO_TICKS(1));
      // No delay after successful receive
    } else if (err == ESP_ERR_TIMEOUT) {
      // Minimal delay when idle
      vTaskDelay(pdMS_TO_TICKS(1));
    } else {
      ESP_LOGE(TAG, "Message reception failed: %s", esp_err_to_name(err));
      vTaskDelay(pdMS_TO_TICKS(5));
    }
  }
}

void process_can_queue_task(void *arg) {
  twai_message_t message;
  int last_temp = GaugeData.scale_value;
  while (1) {
    if (xQueueReceive(canMsgQueue, &message, pdMS_TO_TICKS(1)) == pdPASS) {
      switch (message.identifier) {
        case 0x551:
          process_scale_value(message.data);
          if (GaugeData.scale_value != last_temp) {
            data_ready = true;
            last_temp = GaugeData.scale_value;
          }
          break;
        default:
          break;
      }
      receiving_data = true;
    }
    vTaskDelay(pdMS_TO_TICKS(1));
  }
}
#endif // USE_CANBUS

void setup(void) {
  Serial.begin(115200);
  Serial.println("begin");
  drivers_init();
  set_backlight(80);
  screens_init();
  needle_sweep();
  set_exio(EXIO_PIN4, Low);
  esp_reset_reason_t reason = esp_reset_reason();
  Serial.printf("Reset reason: %d\n", reason);

  #ifdef USE_CANBUS
    // Create CAN message queue
    canMsgQueue = xQueueCreate(CAN_QUEUE_LENGTH, CAN_QUEUE_ITEM_SIZE);
    if (canMsgQueue == NULL) {
      ESP_LOGE(TAG, "Failed to create CAN message queue");
      while (1) vTaskDelay(1000);
    }

    xTaskCreatePinnedToCore(receive_can_task, "Receive_CAN_Task", 4096, NULL, 2, NULL, 1);
    xTaskCreatePinnedToCore(process_can_queue_task, "Process_CAN_Queue_Task", 4096, NULL, 2, NULL, 1);
  #endif

  #ifdef USE_ESPNOW
    // ESP-NOW data reception happens in interrupt callback, no tasks needed
    Serial.println("ESP-NOW receiver ready");
  #endif
}

void loop(void) {
  lv_timer_handler();

  #ifdef USE_CANBUS
    if (data_ready) {
      data_ready = false;
      update_values();
    }
  #endif

  #ifdef USE_ESPNOW
    if (espnow_data_ready) {
      espnow_data_ready = false;
      update_values();
    }
  #endif

  vTaskDelay(pdMS_TO_TICKS(1));
}
